[{"title":"👋🏻Goodbye 2021","date":"2022-01-03T11:11:41.000Z","date_formatted":{"ll":"Jan 3, 2022","L":"01/03/2022","MM-DD":"01-03"},"updated":"2022-01-03T16:39:42.478Z","content":"​\n2021魔幻的一年已经过去，虽说2021好像没干啥大事情，得益于互联网的发展，公众事件吃瓜倒是吃了不少，明星魔幻的操作频频爆出，一边看着明星的高收入同时，一边吃着手中的外卖，同时感慨着世界的参差。\n​\n回到自身来说，做个简单的年度总结。\n​\n👻工作学习\n亮点\n✨随着ExtJS框架的熟悉，业务迭代效率提高了，迭代之余有些许时间来做些思考、优化和创新。于是乎，提了 3 个 2 级创新：\n\n海量列表型数据的渲染方案\n基于 Ext 事件机制实现状态管理方案\nSDK 中实现轻量的 Web 框架\n\n✨技术深度也有更加深入：\n\nWebpack 打包优化实践\nTypeScript 引入项目\n工程化：Gitlab、Jenkins CI/CD\nExtJS 及项目框架源码分析\n\n✨职级晋升 T3\n✨实习生导师\n✨搭建了个人博客（知识沉淀）\n不足\n越是深入感觉技术不够深，很多原理还不是太明白，停留在 API 的使用（Webpack、Vue、Nodejs），明年需要更加深入源码，产出更多的原理分析。\nemmm，英语还是渣哈哈哈，明年继续😵‍💫\n🍖业余生活（多图）\n\n给小盖割蛋蛋（事后），生无可恋哈哈哈🌧\n\n\n\n年度旅游\n\n\n\n杭州西湖\n\n\n\n\n嘉兴乌镇（超棒！旅游推荐，下次要带单反再去一次）\n\n\n\n\n\n\nB站大楼\n\n\n\n\n星爸爸最大烘焙工坊（曾经）\n\n\n\n\n\n上海迪士尼（美好的一天）\n\n\n\n\n\n\n\n东方明珠电视塔\n\n\n\n\n\n","plink":"https://imunoko.top/2022/01/03/Flags-2/"},{"title":"前端现代模块化机制","date":"2021-12-26T17:50:21.000Z","date_formatted":{"ll":"Dec 27, 2021","L":"12/27/2021","MM-DD":"12-27"},"updated":"2022-01-03T16:38:46.895Z","content":"模块化的好处：\n\n避免命名冲突\n代码结构分离，高可维护性、高可复用性\n按需加载\n\n前端模块化的演变\n\nfunction 模式 -&gt; 命名空间（namespace） -&gt; 自执行函数（IIFE） -&gt; IIFE 增强 -&gt; CommonJS、AMD、CMD、ES6 模块化\n1. 全局的 function 模式\n1234567function foo1() &#123;  // do something …&#125;function foo2() &#123;  // do something …&#125;\n利用了函数作用域的特性来分割变量和实现不同的功能\n缺点： 函数都声明在了全局环境下，污染全局变量\n2. 命名空间（namespace）模式\n123456789101112const module = &#123;  data: 1,  sayName: function (name) &#123;    console.log(&quot;hello, &quot; + name);  &#125;,  add: function (num1, num2) &#123;    return num1 + num2;  &#125;,&#125;;module.data = 2; // 修改了 module 中的数据module.sayName(&quot;noko&quot;);\n将变量和函数作为一个对象的属性，整合起来的对象就是一个模块，\n缺点： 数据不安全，容易篡改模块对象中的数据和方法\n3. 自执行函数（IIFE）和闭包\n12345678910111213141516171819;(function(window)&#123;  let data = 1  const setData = (newData) =&gt; &#123;    data = newData  &#125;  const getData = () =&gt; console.log(data)  window.module = &#123;    setData,    getData  &#125;&#125;&#125;)(window)module.getData() // 1module.setData(2)module.getData() // 2\n数据私有化，外部只能通过暴露的方法获取和修改\n缺点： 没有引入依赖的机制\n4. IIFE 增强版 —— 现代模块化的基础\n12345678910111213141516171819202122;(function(window, $)&#123;  let data = 1  const setData = (newData) =&gt; &#123;    data = newData  &#125;  const getData = () =&gt; console.log(data)  const changeColor = () =&gt; &#123;    $(&#x27;body&#x27;).css(&#x27;background&#x27;, &#x27;red&#x27;)  &#125;  window.module = &#123;    setData,    getData,    changeColor  &#125;&#125;&#125;)(window, jQuery)window.changeColor()\n模块互相独立，模块也可以引进另外一个模块，依赖关系清晰\n缺点： 引入其他模块或者第三方库时，要注意引入的先后顺序\n12345// html 文件按顺序引入&lt;script type=&quot;text/javascript&quot; src=&quot;jquery-1.10.1.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;module.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt;  module.changeColor()&lt;/script&gt;\n前端现代模块化\n\n前端目前模块化规范：CommonJS、AMD、CMD、ES6 模块化\nCommonJS\n一个文件就是一个模块，模块间数据互相独立。\n在服务器端，运行时同步加载模块；浏览器端，模块需编译处理。\n四个重要对象：\n\nmodule\n\n每个模块内部都有一个 module 对象\n\nmodule.id 模块的识别符，通常是带有绝对路径的模块文件名。 module.filename 模块的文件名，带有绝对路径。module.loaded 返回一个布尔值，表示模块是否已经完成加载。\nmodule.parent 返回一个对象，表示调用该模块的模块。\nmodule.children 返回一个数组，表示该模块要用到的其他模块。module.exports 表示模块对外输出的值。\n\n\nexports\n\nexports 是 module.exports 的引用，指向 module 对象下的属性 exports，相当于\n1let exports = module.exports;\n避免以下引起 exports 直接复制，切断了与 module.exports 的联系\n12345exports.hello = function () &#123;  return &quot;hello&quot;;&#125;;module.exports = &quot;Hello world&quot;;\n所以不建议使用 exports，而建议使用 module.exports 导出模块。\n\nrequire\n\n\n用于加载 module.exports 的模块\n\n\nglobal\n\n\n所有模块都能访问到 global 对象\n\n使用场景： Node.js、小程序、浏览器（Browserify）\n特点：\n\n运行时加载，并且第一次加载模块后会被缓存\n\n1234require(&quot;./example.js&quot;); // 程序执行到这里开始加载，并且缓存到 require.cache 对象require(&quot;./example.js&quot;).message = &quot;hello&quot;;require(&quot;./example.js&quot;).message;\n程序执行到这里开始加载，并且缓存到 require.cache 对象，所有的模块缓存都在这个对象中。\n\n同步加载模块\n\n1let a = require(&quot;./a&quot;); // 执行到此处时，a.js 才同步下载并执行\n在浏览器中可以使用 browserify 实现，由于 CommonJS 同步加载的方式，而同步意味着阻塞加载，所以在浏览器环境并不适用；而服务器文件都在在本地，加载速度快，CommonJS 是适用的。\n举一个栗子 🌰：\n12345678910// 定义模块math.jslet basicNum = 0;function add(a, b) &#123;  return a + b;&#125;module.exports = &#123;  //在这里写上需要向外暴露的函数、变量  add: add,  basicNum: basicNum,&#125;;\n1234567// 引用自定义的模块时，参数包含路径，可省略.jslet math = require(&#x27;./math&#x27;);math.add(2, 5);// 引用核心模块时，不需要带路径let http = require(&#x27;http&#x27;);http.createService(...).listen(3000);\nAMD 和 require.js\n由于 CommonJS 的同步加载的机制并不适用于浏览器，从而出现了 AMD 异步加载的模块化规范。用于浏览器 require.js，是 AMD 规范的实现。\n\n定义暴露模块\n\n1234//定义没有依赖的模块define(function () &#123;  return 模块;&#125;);\n1234//定义有依赖的模块define([&quot;module1&quot;, &quot;module2&quot;], function (m1, m2) &#123;  return 模块;&#125;);\n\n引入使用模块\n\n123require([&quot;module1&quot;, &quot;module2&quot;], function (m1, m2) &#123;  // 使用m1/m2&#125;);\n使用场景： 浏览器\n特点：\n\n异步加载，提前执行依赖\n\n","plink":"https://imunoko.top/2021/12/27/FE-1/"},{"title":"🍭Flags for 2021","date":"2021-10-26T16:56:21.000Z","date_formatted":{"ll":"Oct 27, 2021","L":"10/27/2021","MM-DD":"10-27"},"updated":"2022-01-03T16:38:54.816Z","content":"2020 年是不同寻常的一年。因为疫情，宅家在过了个很长的年，对于我们忙碌于工作间的打工人们，得以安逸的度过了一个好年，很感激在一线抗疫的辛苦人员，让我们国家的疫情得以控制。✨其实哪有什么岁月安好，不过是有人替我们负重前行。\n由于上家公司的业务和部门的调整，很遗憾我离开了上家的公司😶。这是我毕业后第一家入职的公司，期间还有很多同期入职的小伙伴们，一同成长。部门的工作流程规范，协作流程（DevOps） 和开发环境（脚手架、组件库）完善，期间学到的东西也是满满滴，日常还有前辈们的分享会。公司不大，当时还是个 7,8 百人的公司，正在做上市准备，不过后来小伙伴们也都慢慢的离开，感觉没内味了，后面公司的调整，我就离开了。裸辞那段时间，在家边玩边学习准备了两个月，后面去面了几家感觉很不错，小而美的公司，无奈还是水平不够吧，面试期间也是暴露了自己很多的不足。幸运的后面还是拿到了几家 offer，6月的时候选择入职了深信服，开启了另外的大厂工作旅程。\n在深信服工作的感受就是忙并且充实，往往刚处理完一个需求就是开始准备下一个需求，期间掌握了很多的开发小技巧，提高自己的编码效率，不然跟不上发版进度🙈（💬App 的进度总比我们前端快那么一两周）；另外就得吐槽一下项目的底层框架了，基于 Ext + NW.js，后面融合了 Vue，使用体验不是很良好，Ext 的入门门槛确实比较高，比我学习 React 感觉要吃力，可能也是现在用的人太少了，版本太老和缺少很多学习资料，碰到问题就只能看源码了，网上基本找不到什么答案👀。这个原因感觉也是导致开发效率不高的罪魁祸首，丢！\n生活上 2020 年还算是比较满意的，薪资比原本高了许多，公司福利还算阔以，生活水平好，体重自然也就不自觉的上去了 20 多斤😒。和女票感情稳定，10月30日的时候，我们家还有了新成员，带了一只英短蓝白肥来，一起给小猫咪搭了新家，还准备了好多吃的，开心🤗（写这篇 Flag 的时候已经是个小胖子了）。养猫确实是一件很治愈的事情，据说撸猫还能降低心脏病风险（听说的），2333。PS：猫屎真滴是很臭滴！铲屎久了也习惯了…\n现在新的一年到啦🎉，2021 年又是怎么样的一年呢？立 Flag 的时候到了，新的一年还真是十分的期待呢~💖\n\n💡 2021 - Study Flags\n1. 解决阅读国外技术文档的英语障碍🌎\n一直感觉到语言限制了信息的获取，获取知识和信息存在语言障碍，虽然国内现在也有很多优秀的社区和知识平台，但是始终还是符合国内的大环境的一些技术和信息。世界有很多优秀的程序员，他们大部分在国外，不应该只把技术的视野限制在国内，所以 2021 年的头等 Flags 给了英语学习，目标是能阅读技术文章。\n2. Ext 和 Vue 框架原理🔫\n由于缺乏 Ext 的学习资料，阅读源码可能是最好也最困难的途径了，虽然已是 2000 年左右的框架了，但是现代框架都能依稀看见当时的影子，框架虽老，一些设计模式和解决方案总是经久不衰的。\n至于 Vue，是我第一个接触的框架，第二个是 React，用的差不多一年。Vue 是在我大学的时候学习的，基本也只能写写页面，无法掌握高级用法和精髓。\n今年能把 Vue 和 Ext 的一些原理搞懂，掌握高级用法和提高工作的开发效率是一个非常急迫的事情。另外在考虑的一件事就是，如何在这个框架层面上优化项目的底层框架和组件库，毕竟在开发的时候，公司的框架总是弄得我很糟心🤡\n3. 前端工程化（Webpack 和 Node.js）🔨\n虽说 2020 年底时候开始已经有些工具开始在国内浮出并且传播开来（如 Deno、Vite、esbuild 等），Webpack 复杂但还是实际使用的构建工具，Webpack 在 2021 年还是值得我继续学习深入的工具，毕竟工作中用的也是 Webpack 不是么~\n至于 Node.js 算是 JavaScript 在服务端的解决方案了，不过个人觉得还算是放在工程化上或者作为 BFF，作为服务端的话，Go 和 Java 这些还是主流。\n4. TypeScript💬\nEmmm，惭愧！没有用过😬，作为微软发布的 JavaScript 超集，各大框架都支持并且使用 TypeScript 重构项目的语言，如果不学习，我感觉估计会看不懂 debug 版的源码。另外，TypeScript 静态类型检查的特性，有助于避免日常开发产生的一些类型和隐蔽的问题，这个特性还是很吸引我的，以此提高项目代码的稳定性。\nPS：JavaScript 又向 OOP 迈了一步…🏃‍♀️\n后面的学习 Operation Dtails 会列在我的 XMind 里 …\n","plink":"https://imunoko.top/2021/10/27/Flags-1/"}]